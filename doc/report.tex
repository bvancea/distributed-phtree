\documentclass[11pt,a4paper]{globis-book}

\usepackage{graphicx}
\usepackage[helvetica]{quotchap}
\usepackage{times}
\usepackage{ethfont}
\usepackage[british]{babel}
\usepackage{longtable}
\usepackage{fancyhdr}
\usepackage{shadethm}
\usepackage{makeidx}
\usepackage[a4paper,portrait,twoside,inner=3.25cm,outer=3.5cm,top=3.5cm,bottom=4.0cm]{geometry}
\usepackage{hyperref}
\usepackage{globis}

\renewcommand{\sectfont}{\sffamily\bfseries\Huge}

\setlength{\shadedtextwidth}{\textwidth}
\setlength{\shadeleftshift}{3mm}
\setlength{\shaderightshift}{3mm}
\addtolength{\shadedtextwidth}{-\shadeleftshift}
\addtolength{\shadedtextwidth}{-\shaderightshift}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt}

\sloppy

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{\sffamily\bfseries\small\thepage}
\fancyhead[LO]{\sffamily\bfseries\small\leftmark}
\fancyhead[RE]{\sffamily\bfseries\small\rightmark}
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0pt}

\fancypagestyle{plain}{
   \fancyhf{}
   \fancyfoot[C]{\sffamily\bfseries\small\thepage}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}

% Please adapt the following fields if necessary!
\hypersetup{
    pdftitle = Distributed Ph Tree, 
    pdfauthor = Bogdan Vancea,
    pdfsubject = Master Thesis,
		hidelinks,
    plainpages = false,
    bookmarksnumbered = true
} 

\raggedbottom

% Please adapt the following fields if necessary!
\title{Cluster-Computing and Parallelisation for the
Multi-Dimensional PH-Index}
\category{Master Thesis} 
\author{Bogdan Aurel Vancea}
\email{$<$bvancea@student.ethz.ch$>$}
\professor{Prof. Dr. Moira C. Norrie}
\assistant{Tilmann Zaeschke \\Christoph Zimmerli}
\group{Global Information Systems Group}
\institute{Institute of Information Systems}
\department{Department of Computer Science}
\school{ETH Zurich}
\version{}
\date{\today}
\copyrightyear{2014}

\makeindex

\begin{document}

\frontmatter
\maketitlepage
\cleardoublepage
\pdfbookmark{Contents}{toc}

\chapter*{Abstract}

Here comes the abstract.

\tableofcontents

\mainmatter

% Here comes the content

\chapter{Introduction}
\section{Multi-dimensional Indexes}
\label{sec:title}

\subsection{Background information}
Need to add an introduction here.

This is an example of how to cite a scientific publication~\cite{murolo2013} from your bibliography (BibTeX\footnote{\url{http://en.wikipedia.org/wiki/BibTeX}} file). And this example shows how you create links within your documents, e.g. link to section~\ref{sec:title}.

\chapter{Design and Implementation}
\section{Algorithms}
\subsection{Data partitioning}

Describe here how the key-value pairs are partitioned across the hosts.
\subsection{Data balancing}

Describe how the key-value pairs are balanced across the index nodes.
The cluster should be able to properly balance the amount of keys that are stored in each server.

A simple load balancing strategy would be the following:
\begin{enumerate}
    \item Upon reaching a certain threshold t of keys stored, a host decides it has to split it's zone.
    \item This host first sends a broadcast to all nodes to request the number of keys they all store. It then chooses the hosts with the fewest keys and considers that this key is the split receiver. The splitter decides to split it's zone in half (or in such manner that around half of the keys held in the initial zone are moved to the receiver).
    \item The splitting host sends the keys to the receiver. (What does the received do with them? Duplicates could appear in case of KNN or range querries. ) . 
    \item After the receiver received all keys, the mapping is updated on the Zookeeper.
    \item The splitter then deletes all of the keys send from it's own index (maybe this can be done really fast by removing a bunch of nodes from the index).
\end{enumerate}

Ideas that might not work:
\begin{itemize}
    \item Storing information like the number of keys held by each node in Zookeeper. This would mean that the ZooKeeper would need to be notified on each insert, which would cause severe scalability and availability issues. What could work is that the ZK is notified when each host reaches a certain key threshold (i.e, every 1000 keys inserted, a request is send to ZK).
\end{itemize}
\subsection{Basic Index operation}

Describe the point operations here. These are operations that affect a single key-value pair, like get, put, delete, contains, etc.

\subsection{Iterators}
Describe how iterators are handle when dealing with a cluster of index servers. Describe the current algorithm used and the alternatives.

\subsection{Range search}
Describe how the range search is performed. Describe how the number of hows that need to be querried is reduced and what the alternatives are.

\subsection{K Nearest neighbours}
The K nearest neighbours should be found in the following manner:
\begin{enumerate}
    \item First, a request for the k nearest neighbours is sent to the host that holds the query key. This query will return a number of candidate points.
    \item After finding the furthest neighbour fn from the set of candidates obtained at the previous step on could do the following:
        \begin{itemize}
            \item look into all neighbouring ares and check for neighbours that are closer to q than fn.
            \item find all zones intersecting the square (q - dist(q, fn), q + dist(q, fn)) and perform a knn query into those areas. Then apply an additional knn to combine candidates.
            \item find all zones intersecting the square (q - dist(q, fn), q + dist(q, fn)) and perform a range query in those areas. Then apply an additional knn to combine candidates.
            \item find all zones intersecting the square (q - dist(q, fn), q + dist(q, fn)) and perform a range query followed by a filtering based on dist(q, fn) in those areas. Then apply an additional knn to combine candidates.
        \end{itemize}
\end{enumerate}

This algorithms works under that assumption that all hosts hold at least k points. If that is not the case, and fewer candidates are returned from the first query, one would need to increase the query space and check all of the neighboring areas of the zone holding the query key. To achieve correctness even if all the cluster holds fewer than k keys, one could iteratively query more neighbours in each steps (i.e. first query the 1 - hop neighbourhood, then the 2 - hop neighbourhood) and stop after all of the hosts have been querried.

\section{Implementation}
Describe the technologies used, the reasons for which these technologies were chosen and any alternatives.

Currently used frameworks:
\begin{description}
    \item[ZooKeeper] ZooKeeper is used for stored cluster metadata and membership. Currently, the only alternative would have been to implement such a distributed storage manager manually. Using ZooKeeper saved a lot of development time. 
    \item[Netty] Netty is a Java IO library and it is used to implement the server request handling component. Alternatives would have been Java NIO library.
    \item[Kryo] Kryo is very fast serialization library for Java and it is used to serialize the values that have to be stored on the server. These objects need to be transformed into a represention that can be sent over the network. Kryo is faster than the Java serialization, does not require the implementation of the Serializable interface and transforms the objects into byte arrays. This should make the representation smaller than simply transforming the object to a string.
\end{description}
\chapter{Performance Analysis}
\section{Benchmark}

\chapter{Conclussions}

\appendix

\listoffigures
\listoftables

\chapter*{Acknowledgements}

\newpage
\thispagestyle{empty}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document} 
